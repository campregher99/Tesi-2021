/** @file HL_sys_main.c 
*   @brief Application main file
*   @date 11-Dec-2018
*   @version 04.07.01
*
*   This file contains an empty main function,
*   which can be used for the application.
*/

/* 
* Copyright (C) 2009-2018 Texas Instruments Incorporated - www.ti.com  
* 
* 
*  Redistribution and use in source and binary forms, with or without 
*  modification, are permitted provided that the following conditions 
*  are met:
*
*    Redistributions of source code must retain the above copyright 
*    notice, this list of conditions and the following disclaimer.
*
*    Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the 
*    documentation and/or other materials provided with the   
*    distribution.
*
*    Neither the name of Texas Instruments Incorporated nor the names of
*    its contributors may be used to endorse or promote products derived
*    from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/


/* USER CODE BEGIN (0) */
#include "HL_sys_core.h"
#include "Async_PWM_Triangle_Wave.h"
#include "NHET2_PWM_Range_Monitor.h"
#include "HL_het.h"
#include "HL_system.h"
void calculate_ecmp_compare();
void configNHET1();
void configNHET2();
/* USER CODE END */

/* Include Files */

#include "HL_sys_common.h"

/* USER CODE BEGIN (1) */
/****************************************************************************/
/* Below 12 macros are changeable by user                                   */
/****************************************************************************/

/****************************************************************************/
/* Macros for configuring N2HET2                                            */
/****************************************************************************/

/* Pin number in N2HET2 to monitor the PWM. */
#define NHET2_PIN_MONITOR PIN_HET_16

/* Max Duty cycle threshold beyond which N2HET2 will detect the PWM
 * generated by N2HET1 as fail.
 * If PWM_DUTY is larger than MAX_MONITOR_DUTY_THRESHOLD then N2HET2
 * will detect the fail. */
#define MAX_MONITOR_DUTY_THRESHOLD 80.0

/* Min Duty cycle threshold beyond which N2HET2 will detect the PWM
 * generated by N2HET1 as fail.
 * If PWM_DUTY is less than MIN_MONITOR_DUTY_THRESHOLD then N2HET2
 * will detect the fail. */
#define MIN_MONITOR_DUTY_THRESHOLD 20.0

/* Pin number in N2HET2 to assert when a monitor detects fail */
#define NHET2_MONITOR_ERROR_PIN PIN_HET_0

/****************************************************************************/
/* Macros for configuring N2HET1                                            */
/****************************************************************************/

/* Change to desired PWM Period in terms of (uS)
 * the default 45.52uS will generate a 12-bit resolution on the PWM
 * with each resolution equal to HR=VCLK2=11.11nS.
 * 45.52uS / 11.11ns = 4096.
 */
//#define PWM_PERIOD    45.52F
#define PWM_PERIOD    54.62F

/* Change to desired maximum duty in terms of (%)
 * N2HET1 will generate a varying PWM from 0% duty to
 * the maximum duty specified by PWM_DUTY */
#define PWM_DUTY      100.0

/* allowable LR Prescaler values are 5, 6 and 7. Anything less will
 * will not have enough time slots for the N2HET program. HR prescaler
 * is always divide by 1 from VCLK2.
 * 7 -> one LR = 128 HR
 * 6 -> one LR = 64 HR
 * 5 -> one LR = 32 HR
 */
#define LRPFC 7

/* The NH2ET1 program will automatically increase the PWM
 * modulation from 0% duty cycle to maximum duty cycle
 * specified in PWM_DUTY. When PWM_DUTY is reached it starts
 * to decrease the duty cycle from PWM_DUTY to 0%.
 * DUTY_INCREMENT specifies the delta amount of duty cycle to
 * change from one duty cycle to the next duty cycle while
 * the duty cycle is increasing. This is expressed in terms
 * of (%). For example specifying DUTY_INCREMENT equal to
 * 2 will mean the duty cycle will start at 0% and the next
 * duty cycle will be 2% at a 2% increment. If 0 is
 * specified, then the N2HET1 will increment the duty cycle
 * at 1 HR (High Resolution) clock  */
#define DUTY_INCREMENT   0.0F

/* DUTY_INCREMEMT specifies the delta amount of duty cycle to
 * change from one duty cycle to the next duty cycle while
 * the duty cycle is decreasing. This is expressed in terms
 * of (%). */
#define DUTY_DECREMENT   0.0F

/* The increment delay is the delay at which the PWM modulation
 * will increase the duty cycle from one duty cycle to the
 * next duty cycle. This is expressed in terms
 * of (uS).  For example, if INCREMENT_DELAY is specified for
 * 10.0F (equal to 10uS) then the N2HET1 will wait for 10uS
 * before changing to the new duty cycle */
#define INCREMENT_DELAY  0.0F

/* Decrement delay. The Decrement delay is the delay at
 * which the PWM will decrease the duty cycle. This is expressed
 * in terms of (uS).  */
#define DECREMENT_DELAY  0.0F

/* Pin number in N2HET1 to generate the PWM. */
#define NHET1_PIN_PWM PIN_HET_9


/****************************************************************************/
/* Below macros are used to calculate the epxpected period and pulse width  */
/* to load to N2HET1 for PWM generation and N2HET2 for monitoring             */
/* VCLK2 period in terms of (nS)                                            */
/****************************************************************************/
#define VCLK2_PERIOD (1000 / VCLK2_FREQ)

/* TimeBase LRP Clock Period (nS) for both N2HET1 and N2HET 2*/
#define TBCLK VCLK2_PERIOD * (128 >> (7 - LRPFC))

/* The PWM Period to be loaded to N2HET1 CNT instruction */
#define CNT_MAX_PERIOD (PWM_PERIOD * 1000 / (TBCLK) - 1)

/* The PWM Duty to be loaded to N2HET1 ECMP Instruction */
#define ECMP_MAX_DUTY (PWM_PERIOD * PWM_DUTY / 100.0)  * 1000.0 / (TBCLK)

/* Express the INCREMENT_DELAY in terms of number of LRP clocks */
#define RAMPUP_WAIT (INCREMENT_DELAY * 1000 / (TBCLK))

/* Express the DECREMENT_DELAY in terms of number of LRP clocks */
#define RAMPDOWN_WAIT (DECREMENT_DELAY * 1000 / (TBCLK))

/* DELTA_INCREMENT is amount to be loaded to N2HET1 to increment
 * duty cycle */
#define DELTA_INCREMENT (CNT_MAX_PERIOD * DUTY_INCREMENT / 100)

/* DELTA_DECREMENT is amount to be loaded to N2HET1 to decrement
 * duty cycle */
#define DELTA_DECREMENT (CNT_MAX_PERIOD * DUTY_DECREMENT / 100)

/* Max duty pulse width to compare with in N2HET2*/
#define NHET2_MAX_PULSE_MONITOR  (PWM_PERIOD * (MAX_MONITOR_DUTY_THRESHOLD / 100.0)  * VCLK2_FREQ)

/* Min duty pulse width to compare with in N2HET2*/
#define NHET2_MIN_PULSE_MONITOR  (PWM_PERIOD * (MIN_MONITOR_DUTY_THRESHOLD / 100.0)  * VCLK2_FREQ)

/* Unlock key to for N2HET2 */
#define UNLOCK_KEY 0xAU

/* USER CODE END */

/** @fn void main(void)
*   @brief Application main function
*   @note This function is empty by default.
*
*   This function is called after startup.
*   The user can use this function to implement the application.
*/

/* USER CODE BEGIN (2) */
uint32 ecmp_compare_value = 0;
/* USER CODE END */

int main(void)
{
/* USER CODE BEGIN (3) */
  /* This example uses the N2HET1 generate a triangle wave PWM and uses
   * N2HET2 to monitor the PWM.
   * N2HET1 program: Async_PWM_Triangle_Wave.het
   * N2HET2 program: N2HET2_PWM_Range_Monitor.het
   */

  /* Enable CPU IRQ interrupt */
  _enable_interrupt_();

    /* initialize N2HET1 and N2HET2 based on HalCoGen settings */
  hetInit();

  /* Configure additional settings of N2HET2 based on the macros settings */
  configNHET1();

  /* Configure additional settings of N2HET2 based on the macros settings */
  configNHET2();

  while(1) {

  }

// this statement will never be called, but that's by design. muting warning
#pragma diag_remark 112
/* USER CODE END */

    return 0;
}


/* USER CODE BEGIN (4) */
// unmuting warning
#pragma diag_warning 112



void configNHET1()
{

  /* calculate_ecmp_compare() will calculate the compare value as well as
   * the high resolution delay values to be loaded into the N2HET1 ECMP1
   * instruction for PWM Duty generation based on the input ECMP_MAX_DUTY */
  calculate_ecmp_compare();

  /* Set N2HET1[9] to output */
  hetREG1->DIR = 1 << NHET1_PIN_PWM;

  /* Change the LRPFC according to user input */
  hetREG1->PFR = (LRPFC << 8) ;

  /* Initiailize the PWM period and duty cycle based on the defined parameters */
  hetRAM1->Instruction[pHET_L02_0].Control = (uint32)CNT_MAX_PERIOD | (hetRAM1->Instruction[pHET_L02_0].Control & 0xFD0000);
  hetRAM1->Instruction[pHET_REM_DUTY_0].Data = ecmp_compare_value;

  /* Configure the N2HET1 pin to output the PWM */
  hetRAM1->Instruction[pHET_L03_0].Control = (hetRAM1->Instruction[pHET_L03_0].Control & 0xFFFFE0FF) |
                                    (NHET1_PIN_PWM << 8);
  hetRAM1->Instruction[pHET_L12_0].Control = (hetRAM1->Instruction[pHET_L12_0].Control & 0xFFFFE0FF) |
                                    (NHET1_PIN_PWM << 8);

  /* Configure the amount of delay before increasing to the next duty cycle */
  hetRAM1->Instruction[pHET_L11_0].Data = ((uint32)RAMPUP_WAIT << 7);
  hetRAM1->Instruction[pHET_L13_0].Data = ((uint32)RAMPUP_WAIT << 7);

  /* Configure the amount of delay before decreasing to the next duty cycle */
  hetRAM1->Instruction[pHET_L19_0].Data = ((uint32)RAMPDOWN_WAIT << 7);
  hetRAM1->Instruction[pHET_L21_0].Data = ((uint32)RAMPDOWN_WAIT << 7);

  /* Duty cycle increment amount */
  if ( (uint32)DELTA_INCREMENT == 0){
    hetRAM1->Instruction[pHET_L12_0].Data = (1 << (7 - LRPFC));
  } else {
    hetRAM1->Instruction[pHET_L12_0].Data = (((uint32)DELTA_INCREMENT) << (7 - LRPFC));
  }

  /* Duty cycle decrement amount */
  if ((uint32)DELTA_DECREMENT == 0) {
    hetRAM1->Instruction[pHET_L17_0].Data = (1 << (7 - LRPFC));
  } else {
    hetRAM1->Instruction[pHET_L17_0].Data = (((uint32)DELTA_DECREMENT) << (7 - LRPFC));
  }


  /* Unlock the N2HET program. Initially after reset the N2HET program is locked */
  hetRAM1->Instruction[pHET_L00_0].Data = UNLOCK_KEY << 7;

}
/* This function calculates the compare value and the high resolution delay
 * to be loaded into the N2HET1 ECMP instruction for generating the PWM
 * DUTY cycle according to the user supplied % in PWM_DUTY
 */
void calculate_ecmp_compare()
{
  uint32 uint32_high_phase_width;
  float float_high_phase_width;

  float_high_phase_width = ECMP_MAX_DUTY;
  uint32_high_phase_width = ECMP_MAX_DUTY;

  /* the (float_high_phase_width - uint32_high_phase_width) expression will
   * obtain the decimal value in terms of # of LRP (loop resolution period)
   * clock. Once we get the deciminal falue we will multiply by 128 to
   * obtain the number of HR (high resolution) clocks. 1 LRP = 128 HR as
   * configured in the HalcoGen for this example.
   *
   * (uint32_high_phase_width << 7) will form the LRP compare value
   * ((float_high_phase_width - uint32_high_phase_width) * 128) forms the
   * high resolution delay
   */
  ecmp_compare_value = (uint32)(uint32_high_phase_width << 7) |
                   (uint32)((float_high_phase_width - uint32_high_phase_width) * (128 >> (7 - LRPFC)));
}
/* configure N2HET2 enables the interrupts associated with the N2HET2 instructions
 * that will monitor and detect and PWM failure. It also loads the epxected
 * period and duty width to compare with into the N2HET2 RAM */
void configNHET2()
{

  /* Set N2HET2[NHET2_MONITOR_ERROR_PIN] to output */
  hetREG2->DIR = 1 << NHET2_MONITOR_ERROR_PIN;

  /* Change the LRPFC according to user input */
  hetREG2->PFR = (LRPFC << 8) ;

  /* Enable interrupt for instructions in N2HET2*/
  hetREG2->INTENAS = (1 << pHET_L08_1) | (1 << pHET_L10_1) ;

  /* Configure the PCNT RISE2FALL to select pin NHET2_PIN_MONITOR */
  hetRAM2->Instruction[pHET_L02_1].Program = (hetRAM2->Instruction[pHET_L02_1].Program & 0xFFFFFFE0) |
                                  (uint32)(NHET2_PIN_MONITOR);
  /* Configure the ECNT to select pin NHET2_PIN_MONITOR */

  hetRAM2->Instruction[pHET_L03_1].Control = (hetRAM2->Instruction[pHET_L03_1].Control & 0xFFFFE0FF) |
                                  (NHET2_PIN_MONITOR << 8);

  /* calculate the max/min high phase duty width in terms of # of total HR cycles
   * and then write to the pulse field in the N2HET program
   * The max/min pulse is added one to compensate for the fact that
   * the  pulse measurement can have a +/- 1 HR clock of tolerance.
   */
  hetRAM2->Instruction[pHET_REM_MAX_DUTY_1].Data = (uint32)(NHET2_MAX_PULSE_MONITOR + 1);
  hetRAM2->Instruction[pHET_REM_MIN_DUTY_1].Data = (uint32)(NHET2_MIN_PULSE_MONITOR + 1);

  /* Configure the N2HET2 pin to output the error */
  hetRAM2->Instruction[pHET_L12_1].Control = (hetRAM2->Instruction[pHET_L12_0].Control & 0xFFFFE0FF) |
                                    (NHET2_MONITOR_ERROR_PIN << 8);
  hetRAM2->Instruction[pHET_L14_1].Control = (hetRAM2->Instruction[pHET_L14_0].Control & 0xFFFFE0FF) |
                                    (NHET2_MONITOR_ERROR_PIN << 8);

  /* Unlock the N2HET program. Initially after reset the N2HET program is locked */
  hetRAM2->Instruction[pHET_L00_1].Data = UNLOCK_KEY << 7;

}

/* USER CODE END */
